import * as XLSX from 'xlsx';
import JSZip from 'jszip';
import { saveAs } from 'file-saver';
import { SheetProps } from '../models/form';

const authorName = 'React-Spreadsheeter';

function genString(addString?: string, addTimeString: boolean = true): string {
  let generated = '';
  if (addTimeString) {
    generated = new Date().toISOString().slice(2, 19).replace(/[:\-]/g, '') + '-';
  }
  if (!addString) {
    const rArr = new Uint8Array(4);
    crypto.getRandomValues(rArr);
    generated += Array.from(rArr, (i) =>
      (i < 10 ? '0' + i : i).toString(16)
    ).join('');
  } else {
    generated += addString;
  }
  return generated;
}

function transformCSV(csv: string) {
  const tCSV = '"' + csv.replace(/"/g, '\'').replace(/,/g, '";"').replace(/(\n)/gm, '"\r\n"') + '"\r\n';
  return tCSV;
}

function csvToXLSX(sheets: SheetProps[], fileName: string): void {
  if (!sheets || sheets.length < 1) {
    throw new Error('No data to export...');
  }
  const wbToWrite: XLSX.WorkBook = XLSX.read(
    transformCSV(sheets[0].data), { type: 'string' });
  // const wbToWrite = XLSX.utils.book_new();
  // if (!wbToWrite.Props) wbToWrite.Props = {};
  /* eslint-enable @typescript-eslint/dot-notation */
  wbToWrite.Props = {
    ...wbToWrite.Props,
    /* eslint-disable @typescript-eslint/naming-convention */
    Title: fileName,
    Author: authorName,
    CreatedDate: new Date(),
    ModifiedDate: new Date(),
    Comments: 'Generated by ' + authorName,
    Keywords: 'CSV,sheets',
    Category: 'Spreadsheets'
    /* eslint-enable @typescript-eslint/naming-convention */
  };
  // sheets.forEach(({ name, data }) =>
  //   XLSX.utils.book_append_sheet(
  //     wbToWrite,
  //     XLSX.utils.aoa_to_sheet(data),
  //     name
  //   )
  // );
  // rename and relocate sheet
  wbToWrite.SheetNames[0] = sheets[0].name;
  /* eslint-disable @typescript-eslint/dot-notation */
  wbToWrite.Sheets[sheets[0].name] = wbToWrite.Sheets['Sheet1'];
  delete wbToWrite.Sheets['Sheet1'];
  sheets.slice(1).forEach(({ name, data }) => {
    const wb: XLSX.WorkBook = XLSX.read(transformCSV(data), { type: 'string' });
    wbToWrite.SheetNames.push(name);
    wbToWrite.Sheets[name] = wb.Sheets['Sheet1'];
  });

  XLSX.writeFile(wbToWrite, fileName);
}

function popupDialog(content: string, fileName: string, format: string) {
  let blobToSave: Blob;
  if (format === 'csv') {
    blobToSave = new Blob([transformCSV(content)], {
      type: 'text/csv;charset=utf-8'
    });
  } else {
    blobToSave = new Blob([content], { type: 'text/plain;charset=utf-8'});
  }
  saveAs(blobToSave, fileName + '.' + format);
  // Without using file-saver ----------------------------------------
  // const anchor: HTMLAnchorElement = document.createElement('a');
  // if (format.startsWith('data:')) {
  //   anchor.download = fileName;
  //   anchor.href = format + content;
  // } else {
  //   anchor.download = fileName + '.' + format;
  //   anchor.href = `data:text/${format === 'csv' ? 'csv' : 'plain'};charset=utf-16,` + content;
  // }
  // anchor.click();
  // anchor.remove();
}

function saveSheet(sheets: SheetProps[], fileName: string, format: string) {
  if (format === 'xlsx') {
    csvToXLSX(sheets, fileName + '.' + format);
  } else if (format === 'zip') {
    const zip = new JSZip();
    sheets.forEach(({data, name}) => zip.file(name + '.csv', data));
    zip.generateAsync({
      type: 'blob', comment: 'Generated by ' + authorName}, (metadata) => {
      // onUpdate callback
      console.log(`Generating archive (${
        metadata.currentFile ?? 'done'
      }): ${metadata.percent.toFixed(2)}%`);
    }).then((content) => {
      saveAs(content, fileName + '.zip');
    });
  } else {
    sheets.forEach(({ name, data }) => {
      popupDialog(data, fileName + '-' + name, format);
    });
  }
}

export { genString, saveSheet };
